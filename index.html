<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Boreas</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="War never stop but is unknown">
<meta property="og:type" content="website">
<meta property="og:title" content="Boreas">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Boreas">
<meta property="og:description" content="War never stop but is unknown">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Boreas" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/myhead.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/myhead.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Taylor</a></h1>
		</hgroup>

		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">时间轴</a></li>
				        
							<li><a href="/categories">分类</a></li>
				        
							<li><a href="/tags/">标签</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Taylor</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/myhead.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Taylor</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">时间轴</a></li>
		        
					<li><a href="/categories">分类</a></li>
		        
					<li><a href="/tags/">标签</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/06/hello-world/" class="article-date">
  	<time datetime="2019-11-06T07:28:19.812Z" itemprop="datePublished">2019-11-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/06/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-IPC-InterProcess-Communication" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/08/IPC-InterProcess-Communication/" class="article-date">
  	<time datetime="2018-09-08T07:40:10.000Z" itemprop="datePublished">2018-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/IPC-InterProcess-Communication/">
        IPC(InterProcess Communication)
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>进程间通信IPC (InterProcess Communication)<br>部分出自: <a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">https://www.jianshu.com/p/c1015f5ffa74</a></p>
<hr>
<p>##进程间通信的概念<br>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）</p>
<p><img src="IPC-InterProcess-Communication/IPC1.webp" alt="进程间管道通信模型"></p>
<h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><h3 id="管道-匿名管道-pipe"><a href="#管道-匿名管道-pipe" class="headerlink" title="管道/匿名管道(pipe)"></a>管道/匿名管道(pipe)</h3><blockquote>
<p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。<br>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);<br>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。<br>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>
</blockquote>
<p><img src="IPC-InterProcess-Communication/IPC2.jpg" alt="进程间管道通信模型"><br><strong>管道的实质：</strong><br>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
<p><strong>管道的局限：</strong><br>管道的主要局限性正体现在它的特点上：</p>
<blockquote>
<p>只支持单向数据流；<br>只能用于具有亲缘关系的进程之间；<br>没有名字；<br>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；<br>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</p>
</blockquote>
<h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。<br>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p>
<blockquote>
<p>匿名管道和有名管道总结：</p>
<blockquote>
<p>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br>（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br>（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p>
</blockquote>
</blockquote>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。<br>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。<br>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p>
<blockquote>
<blockquote>
<p>Linux系统中常用信号：<br>（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br>（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。<br>（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。<br>（4）SIGBUS和SIGSEGV：进程访问非法地址。<br>（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。<br>（6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。<br>（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。<br>（8）SIGALRM：定时器信号。<br>（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p>
</blockquote>
</blockquote>
<p><strong>信号来源</strong></p>
<p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p>
<blockquote>
<p>硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。<br>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</p>
</blockquote>
<p><strong>信号生命周期和处理流程</strong><br>（1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；<br>（2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br>（3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</p>
<p><img src="IPC-InterProcess-Communication/IPC3.png" alt="信号的生命周期"></p>
<h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。<br>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。<br>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</p>
<blockquote>
<p>（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br>（2）消息队列允许一个或多个进程向它写入与读取消息.<br>（3）管道和消息队列的通信数据都是先进先出的原则。<br>（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br>（5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br>（6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p>
</blockquote>
<h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><p>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。<br>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。<br>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。<br><img src="IPC-InterProcess-Communication/IPC4.png" alt="共享内存原理图"></p>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br>为了获得共享资源，进程需要执行下列操作：<br>（1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。<br>（2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。<br>（3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。</p>
<p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。<br><img src="IPC-InterProcess-Communication/IPC5.png" alt="两个进程使用一个二值信号量"><br><img src="IPC-InterProcess-Communication/IPC6.png" alt="两个进程所以用一个Posix有名二值信号量"><br><img src="IPC-InterProcess-Communication/IPC7.png" alt="一个进程两个线程共享基于内存的信号量"></p>
<blockquote>
<p>信号量与普通整型变量的区别：<br>（1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br>（2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p>
</blockquote>
<blockquote>
<p>信号量与互斥量之间的区别：<br>（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br><strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br><strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br>（2）互斥量值只能为0/1，信号量值可以为非负整数。<br>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br>（3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p>
</blockquote>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。<br><img src="IPC-InterProcess-Communication/IPC8.png" alt="Socket是应用层和传输层之间的桥梁"><br>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<p><strong>套接字特性</strong><br>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br>（1）套接字的域<br>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br>一是<strong>AF_INET，它指的是Internet网络</strong>。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br><strong>另一个域AF_UNIX，表示UNIX文件系统</strong>，它就是文件输入/输出，而它的地址就是文件名。<br>（2）套接字的端口号<br>每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br>（3）套接字协议类型<br>因特网提供三种通信机制，<br><strong>一是流套接字</strong>，流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br><strong>二个是数据报套接字</strong>，它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br><strong>三是原始套接字</strong>，原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p>
<blockquote>
<p>原始套接字与标准套接字的区别在于：<br>原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p>
</blockquote>
<p>套接字通信的建立<br><img src="IPC-InterProcess-Communication/IPC8.png" alt="Socket通信基本流程"><br>Socket通信基本流程</p>
<p><strong>服务器端</strong><br>（1）首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。<br>（2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。<br>（3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。<br>（4）最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p>
<p><strong>客户端</strong><br>（1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br>（2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）</p>
<h2 id="进程间通信实例"><a href="#进程间通信实例" class="headerlink" title="进程间通信实例"></a>进程间通信实例</h2><h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h3><p><strong>管道的创建：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>管道两端可分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的I/O函数都可以用于管道，如close、read、write等等。</p>
<blockquote>
<p><strong>从管道中读取数据：</strong><br> 如果管道的写端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为0；<br>当管道的写端存在时，如果请求的字节数目大于PIPE_BUF，则返回管道中现有的数据字节数，如果请求的字节数目不大于PIPE_BUF，则返回管道中现有数据字节数（此时，管道中数据量小于请求的数据量）；或者返回请求的字节数（此时，管道中数据量不小于请求的数据量）。<br><strong>向管道中写入数据：</strong><br>向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> r_buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span> w_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> writenum;</span><br><span class="line">    <span class="keyword">int</span> rnum;</span><br><span class="line">    <span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));  </span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);   </span><br><span class="line">        rnum=<span class="built_in">read</span>(pipe_fd[<span class="number">0</span>],r_buf,<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child: readnum is %d\n"</span>,rnum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);<span class="comment">//write</span></span><br><span class="line">    <span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));  </span><br><span class="line">    <span class="keyword">if</span>((writenum=<span class="built_in">write</span>(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">1024</span>))==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write to pipe error\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the bytes write to pipe is %d \n"</span>, writenum);</span><br><span class="line">    writenum=<span class="built_in">write</span>(pipe_fd[<span class="number">1</span>],w_buf,<span class="number">4096</span>);</span><br><span class="line">    <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">1000</span></span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">1000</span>  <span class="comment">//注意，此行输出说明了写入的非原子性</span></span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">1000</span></span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">1000</span></span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">1000</span></span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">120</span>  <span class="comment">//注意，此行输出说明了写入的非原子性</span></span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">0</span></span><br><span class="line">the bytes <span class="built_in">write</span> to pipe <span class="number">0</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="有名管道-FIFO-1"><a href="#有名管道-FIFO-1" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p><strong>有名管道的创建</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">mode_t</span> mode)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo pathname</span><br></pre></td></tr></table></figure>
<p>有名管道的打开规则<br>有名管道比管道多了一个打开操作：open。</p>
<p><strong>FIFO的打开规则：</strong></p>
<blockquote>
<p>如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。</p>
</blockquote>
<blockquote>
<p>如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。</p>
</blockquote>
<p><strong>有名管道的读写规则</strong><br>从FIFO中读取数据：</p>
<p>约定：如果一个进程为了从FIFO中读取数据而阻塞打开FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。</p>
<p>向FIFO中写入数据：</p>
<p>约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。</p>
<p>命名管道有阻塞标志的设定。</p>
<p>程序1：写FIFO的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO_SERVER <span class="meta-string">"/tmp/fifoserver"</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line"><span class="comment">//参数为即将写入的字节数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> w_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> real_wnum;</span><br><span class="line">    <span class="built_in">memset</span>(w_buf,<span class="number">0</span>,<span class="number">4096</span>*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>((mkfifo(FIFO_SERVER,O_CREAT|O_EXCL)&lt;<span class="number">0</span>)&amp;&amp;(errno!=EEXIST))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot create fifoserver\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span>(errno==ENXIO)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"open error; no reading process\n"</span>);</span><br><span class="line">         </span><br><span class="line">        fd=<span class="built_in">open</span>(FIFO_SERVER,O_WRONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设置非阻塞标志</span></span><br><span class="line">    <span class="comment">//fd=open(FIFO_SERVER,O_WRONLY,0);</span></span><br><span class="line">    <span class="comment">//设置阻塞标志</span></span><br><span class="line">    real_wnum=<span class="built_in">write</span>(fd,w_buf,<span class="number">2048</span>);</span><br><span class="line">    <span class="keyword">if</span>(real_wnum==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"write to fifo error; try later\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"real write num is %d\n"</span>,real_wnum);</span><br><span class="line">    real_wnum=<span class="built_in">write</span>(fd,w_buf,<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">//5000用于测试写入字节大于4096时的非原子性</span></span><br><span class="line">    <span class="comment">//real_wnum=write(fd,w_buf,4096);</span></span><br><span class="line">    <span class="comment">//4096用于测试写入字节不大于4096时的原子性</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(real_wnum==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"try later\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO_SERVER <span class="meta-string">"/tmp/fifoserver"</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> r_buf[<span class="number">4096</span>*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>  fd;</span><br><span class="line">    <span class="keyword">int</span>  r_size;</span><br><span class="line">    <span class="keyword">int</span>  ret_size;</span><br><span class="line">    r_size=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"requred real read bytes %d\n"</span>,r_size);</span><br><span class="line">    <span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">    fd=<span class="built_in">open</span>(FIFO_SERVER,O_RDONLY|O_NONBLOCK,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//fd=open(FIFO_SERVER,O_RDONLY,0);</span></span><br><span class="line">    <span class="comment">//在此处可以把读程序编译成两个不同版本：阻塞版本及非阻塞版本</span></span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open %s for read error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">memset</span>(r_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(r_buf));</span><br><span class="line">        ret_size=<span class="built_in">read</span>(fd,r_buf,r_size);</span><br><span class="line">        <span class="keyword">if</span>(ret_size==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(errno==EAGAIN)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"no data avlaible\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"real read bytes %d\n"</span>,ret_size);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    pause();</span><br><span class="line">    unlink(FIFO_SERVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html</a></p>
<hr>
<p>linux下的信号应用并没有想象的那么恐怖，程序员所要做的最多只有三件事情：</p>
<blockquote>
<ul>
<li>安装信号（推荐使用sigaction()）；</li>
<li>实现三参数信号处理函数，handler(int signal,struct siginfo *info, void *)；</li>
<li>发送信号，推荐使用sigqueue()。</li>
</ul>
</blockquote>
<p>实际上，对有些信号来说，只要安装信号就足够了（信号处理方式采用缺省或忽略）。其他可能要做的无非是与信号集相关的几种操作。</p>
<p>1、signal()<br>#include &lt;signal.h&gt; </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> signum, <span class="keyword">void</span> (*handler))(<span class="keyword">int</span>)))(<span class="keyword">int</span>); </span><br><span class="line"><span class="comment">// 如果该函数原型不容易理解的话，可以参考下面的分解方式来理解： </span></span><br><span class="line">typedef void (*sighandler_t)(int)； </span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler));</span><br></pre></td></tr></table></figure>
<p>第一个参数指定信号的值，第二个参数指定针对前面信号值的处理，可以忽略该信号（参数设为SIG_IGN）；可以采用系统默认方式处理信号(参数设为SIG_DFL)；也可以自己实现处理方式(参数指定一个函数地址)。<br>如果signal()调用成功，返回最后一次为安装信号signum而调用signal()时的handler值；失败则返回SIG_ERR。</p>
<p>2、sigaction() </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line">int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));</span><br></pre></td></tr></table></figure>
<p>sigaction函数用于改变进程接收到特定信号后的行为。该函数的第一个参数为信号的值，可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误）。第二个参数是指向结构sigaction的一个实例的指针，在结构sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理；第三个参数oldact指向的对象用来保存原来对相应信号的处理，可指定oldact为NULL。如果把第二、第三个参数都设为NULL，那么该函数可用于检查信号的有效性。</p>
<p>第二个参数最为重要，其中包含了对指定信号的处理、信号所传递的信息、信号处理函数执行过程中应屏蔽掉哪些函数等等。</p>
<p>sigaction结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">         <span class="keyword">union</span>&#123;</span><br><span class="line">           <span class="keyword">__sighandler_t</span> _sa_handler;</span><br><span class="line">           <span class="keyword">void</span> (*_sa_sigaction)(<span class="keyword">int</span>,struct siginfo *, <span class="keyword">void</span> *)；</span><br><span class="line">           &#125;_u</span><br><span class="line">                    <span class="keyword">sigset_t</span> sa_mask；</span><br><span class="line">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags； </span><br><span class="line">                 <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>)；</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>
<p>其中，sa_restorer，已过时，POSIX不支持它，不应再被使用。<br><strong>实例一：信号发送及处理</strong><br>实现一个信号接收程序sigreceive（其中信号安装由sigaction（））。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span>   </span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    sig=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">     </span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags=SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction=new_op;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(sigaction(sig,&amp;act,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"install sigal error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wait for the signal\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">siginfo_t</span> *info,<span class="keyword">void</span> *myact)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"receive signal %d"</span>, signum);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明，命令行参数为信号值，后台运行sigreceive signo &amp;，可获得该进程的ID，假设为pid，然后再另一终端上运行kill -s signo pid验证信号的发送接收及处理。同时，可验证信号的排队问题。<br>注：可以用sigqueue实现一个命令行信号发送程序sigqueuesend，见 附录1。</p>
<p><strong>实例二：信号传递附加信息</strong><br>主要包括两个实例：</p>
<p>向进程本身发送信号，并传递指针参数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span>   </span><br><span class="line">    <span class="keyword">union</span> sigval mysigval;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;      </span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        data[i]=<span class="string">'2'</span>;</span><br><span class="line">    mysigval.sival_ptr=data;</span><br><span class="line">     </span><br><span class="line">    sig=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    pid=getpid();</span><br><span class="line">     </span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_sigaction=new_op;<span class="comment">//三参数信号处理函数</span></span><br><span class="line">    act.sa_flags=SA_SIGINFO;<span class="comment">//信息传递开关</span></span><br><span class="line">    <span class="keyword">if</span>(sigaction(sig,&amp;act,<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"install sigal error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wait for the signal\n"</span>);</span><br><span class="line">        sigqueue(pid,sig,mysigval);<span class="comment">//向本进程发送信号，并传递附加信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">siginfo_t</span> *info,<span class="keyword">void</span> *myact)</span><span class="comment">//三参数信号处理函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n "</span>,(*( (<span class="keyword">char</span>*)((*info).si_ptr)+i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"handle signal %d over;"</span>,signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，信号实现了附加信息的传递，信号究竟如何对这些信息进行处理则取决于具体的应用。</p>
<p>2、    不同进程间传递整型参数：把1中的信号发送和接收放在两个程序中，并且在发送过程中传递整型参数。<br>信号接收程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">siginfo_t</span>*,<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;      </span><br><span class="line">     </span><br><span class="line">    pid=getpid();</span><br><span class="line">    sig=atoi(argv[<span class="number">1</span>]);  </span><br><span class="line">     </span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_sigaction=new_op;</span><br><span class="line">    act.sa_flags=SA_SIGINFO;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(sig,&amp;act,<span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"install sigal error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wait for the signal\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_op</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">siginfo_t</span> *info,<span class="keyword">void</span> *myact)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the int value is %d \n"</span>,info-&gt;si_int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号发送程序：命令行第二个参数为信号值，第三个参数为接收进程ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> signum;</span><br><span class="line">    <span class="keyword">union</span> sigval mysigval;</span><br><span class="line">    signum=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    pid=(<span class="keyword">pid_t</span>)atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    mysigval.sival_int=<span class="number">8</span>;<span class="comment">//不代表具体含义，只用于说明问题</span></span><br><span class="line">    <span class="keyword">if</span>(sigqueue(pid,signum,mysigval)==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send error\n"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：<strong>实例2的两个例子侧重点在于用信号来传递信息</strong>，目前关于在linux下通过信号传递信息的实例非常少，倒是Unix下有一些，但传递的基本上都是关于传递一个整数，传递指针的我还没看到。我一直没有实现不同进程间的指针传递（实际上更有意义），也许在实现方法上存在问题吧，请实现者email我。</p>
<p><strong>实例三：信号阻塞及信号集操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"signal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"unistd.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_op</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> new_mask,old_mask,pending_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags=SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction=(<span class="keyword">void</span>*)my_op;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(SIGRTMIN+<span class="number">10</span>,&amp;act,<span class="literal">NULL</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"install signal SIGRTMIN+10 error\n"</span>);</span><br><span class="line">    sigemptyset(&amp;new_mask);</span><br><span class="line">    sigaddset(&amp;new_mask,SIGRTMIN+<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(sigprocmask(SIG_BLOCK, &amp;new_mask,&amp;old_mask))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"block signal SIGRTMIN+10 error\n"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"now begin to get pending mask and unblock SIGRTMIN+10\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(sigpending(&amp;pending_mask)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get pending mask error\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(sigismember(&amp;pending_mask,SIGRTMIN+<span class="number">10</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"signal SIGRTMIN+10 is pending\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(sigprocmask(SIG_SETMASK,&amp;old_mask,<span class="literal">NULL</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unblock signal error\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"signal unblocked\n"</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_op</span><span class="params">(<span class="keyword">int</span> signum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"receive signal %d \n"</span>,signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译该程序，并以后台方式运行。在另一终端向该进程发送信号(运行kill -s 42 pid，SIGRTMIN+10为42)，查看结果可以看出几个关键函数的运行机制，信号集相关操作比较简单。</p>
<p>注：在上面几个实例中，使用了printf()函数，只是作为诊断工具，pringf()函数是不可重入的，不应在信号处理函数中使用。</p>
<h2 id="消息队列-报文队列"><a href="#消息队列-报文队列" class="headerlink" title="消息队列(报文队列)"></a>消息队列(报文队列)</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html</a></p>
<hr>
<p><strong>对消息队列的操作无非有下面三种类型：</strong><br>1、 打开或创建消息队列<br>消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以，要获得一个消息队列的描述字，只需提供该消息队列的键值即可；</p>
<p>注：消息队列描述字是由在系统范围内唯一的键值生成的，而键值可以看作对应系统内的一条路经。</p>
<p>2、 读写操作</p>
<p>消息读写操作非常简单，对开发人员来说，每个消息都类似如下的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mtype成员代表消息类型，从消息队列中读取消息的一个重要依据就是消息的类型；mtext是消息内容，当然长度不一定为1。因此，对于发送消息来说，首先预置一个msgbuf缓冲区并写入消息类型和内容，调用相应的发送函数即可；对读取消息来说，首先分配这样一个msgbuf缓冲区，然后把消息读入该缓冲区即可。<br>3、 获得或设置消息队列属性：</p>
<p>消息队列的信息基本上都保存在消息队列头中，因此，可以分配一个类似于消息队列头的结构(struct msqid_ds)来返回消息队列的属性；同样可以设置该数据结构。</p>
<p><strong>linux为操作系统V进程间通信的三种方式（消息队列、信号灯、共享内存区）</strong>提供了一个统一的用户界面：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> call, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> third, <span class="keyword">void</span> * ptr, <span class="keyword">long</span> fifth)</span></span>;</span><br><span class="line">第一个参数指明对IPC对象的操作方式，对消息队列而言共有四种操作：MSGSND、MSGRCV、MSGGET以及MSGCTL，分别代表向消息队列发送消息、从消息队列读取消息、打开或创建消息队列、控制消息队列；first参数代表唯一的IPC对象；下面将介绍四种操作。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span><span class="params">( MSGGET, intfirst, intsecond, intthird, <span class="keyword">void</span>*ptr, longfifth)</span></span>;</span><br><span class="line">与该操作对应的系统V调用为：int msgget( (key_t)first，second)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span><span class="params">( MSGCTL, intfirst, intsecond, intthird, <span class="keyword">void</span>*ptr, longfifth)</span></span></span><br><span class="line">与该操作对应的系统V调用为：int msgctl( first，second, (struct msqid_ds*) ptr)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span><span class="params">( MSGSND, intfirst, intsecond, intthird, <span class="keyword">void</span>*ptr, longfifth)</span></span>; </span><br><span class="line">与该操作对应的系统V调用为：int msgsnd( first, (struct msgbuf*)ptr, second, third)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipc</span><span class="params">( MSGRCV, intfirst, intsecond, intthird, <span class="keyword">void</span>*ptr, longfifth)</span></span>; </span><br><span class="line">与该操作对应的系统V调用为：int msgrcv( first，(struct msgbuf*)ptr, second, fifth,third)，</span><br></pre></td></tr></table></figure>
<p>注：本人不主张采用系统调用ipc()，而更倾向于采用系统V或者POSIX进程间通信API。原因如下：</p>
<blockquote>
<p>虽然该系统调用提供了统一的用户界面，但正是由于这个特性，它的参数几乎不能给出特定的实际意义（如以first、second来命名参数），在一定程度上造成开发不便。<br>正如ipc手册所说的：ipc()是linux所特有的，编写程序时应注意程序的移植性问题；<br>该系统调用的实现不过是把系统V IPC函数进行了封装，没有任何效率上的优势；<br>系统V在IPC方面的API数量不多，形式也较简洁。</p>
</blockquote>
<p>消息队列应用相对较简单，下面实例基本上覆盖了对消息队列的所有操作，同时，程序输出结果有助于加深对前面所讲的某些规则及消息队列限制的理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_stat</span><span class="params">(<span class="keyword">int</span>,struct msqid_ds )</span></span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gflags,sflags,rflags;</span><br><span class="line"><span class="keyword">key_t</span> key;</span><br><span class="line"><span class="keyword">int</span> msgid;</span><br><span class="line"><span class="keyword">int</span> reval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgsbuf</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> mtype;</span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">    &#125;msg_sbuf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgmbuf</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">10</span>];</span><br><span class="line">    &#125;msg_rbuf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">msg_ginfo</span>,<span class="title">msg_sinfo</span>;</span></span><br><span class="line"><span class="keyword">char</span>* msgpath=<span class="string">"/unix/msgqueue"</span>;</span><br><span class="line">key=ftok(msgpath,<span class="string">'a'</span>);</span><br><span class="line">gflags=IPC_CREAT|IPC_EXCL;</span><br><span class="line">msgid=msgget(key,gflags|<span class="number">00666</span>);</span><br><span class="line"><span class="keyword">if</span>(msgid==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"msg create error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个消息队列后，输出消息队列缺省属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">sflags=IPC_NOWAIT;</span><br><span class="line">msg_sbuf.mtype=<span class="number">10</span>;</span><br><span class="line">msg_sbuf.mtext[<span class="number">0</span>]=<span class="string">'a'</span>;</span><br><span class="line">reval=msgsnd(msgid,&amp;msg_sbuf,<span class="keyword">sizeof</span>(msg_sbuf.mtext),sflags);</span><br><span class="line"><span class="keyword">if</span>(reval==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message send error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送一个消息后，输出消息队列属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">rflags=IPC_NOWAIT|MSG_NOERROR;</span><br><span class="line">reval=msgrcv(msgid,&amp;msg_rbuf,<span class="number">4</span>,<span class="number">10</span>,rflags);</span><br><span class="line"><span class="keyword">if</span>(reval==<span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read msg error\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read from msg queue %d bytes\n"</span>,reval);</span><br><span class="line"><span class="comment">//从消息队列中读出消息后，输出消息队列属性</span></span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line">msg_sinfo.msg_perm.uid=<span class="number">8</span>;<span class="comment">//just a try</span></span><br><span class="line">msg_sinfo.msg_perm.gid=<span class="number">8</span>;<span class="comment">//</span></span><br><span class="line">msg_sinfo.msg_qbytes=<span class="number">16388</span>;</span><br><span class="line"><span class="comment">//此处验证超级用户可以更改消息队列的缺省msg_qbytes</span></span><br><span class="line"><span class="comment">//注意这里设置的值大于缺省值</span></span><br><span class="line">reval=msgctl(msgid,IPC_SET,&amp;msg_sinfo);</span><br><span class="line"><span class="keyword">if</span>(reval==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"msg set info error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">msg_stat(msgid,msg_ginfo);</span><br><span class="line"><span class="comment">//验证设置消息队列属性</span></span><br><span class="line">reval=msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);<span class="comment">//删除消息队列</span></span><br><span class="line"><span class="keyword">if</span>(reval==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"unlink msg queue error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg_stat</span><span class="params">(<span class="keyword">int</span> msgid,struct msqid_ds msg_info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> reval;</span><br><span class="line">sleep(<span class="number">1</span>);<span class="comment">//只是为了后面输出时间的方便</span></span><br><span class="line">reval=msgctl(msgid,IPC_STAT,&amp;msg_info);</span><br><span class="line"><span class="keyword">if</span>(reval==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get msg info error\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"current number of bytes on queue is %d\n"</span>,msg_info.msg_cbytes);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"number of messages in queue is %d\n"</span>,msg_info.msg_qnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"max number of bytes on queue is %d\n"</span>,msg_info.msg_qbytes);</span><br><span class="line"><span class="comment">//每个消息队列的容量（字节数）都有限制MSGMNB，值的大小因系统而异。在创建新的消息队列时，//msg_qbytes的缺省值就是MSGMNB</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid of last msgsnd is %d\n"</span>,msg_info.msg_lspid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pid of last msgrcv is %d\n"</span>,msg_info.msg_lrpid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last msgsnd time is %s"</span>, ctime(&amp;(msg_info.msg_stime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last msgrcv time is %s"</span>, ctime(&amp;(msg_info.msg_rtime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"last change time is %s"</span>, ctime(&amp;(msg_info.msg_ctime)));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"msg uid is %d\n"</span>,msg_info.msg_perm.uid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"msg gid is %d\n"</span>,msg_info.msg_perm.gid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html</a><br>有点完全看不懂</p>
<hr>
<p>这是IBM的一个实例：<br><strong>范例1：两个进程通过映射普通文件实现共享内存通信</strong><br>范例1包含两个子程序：map_normalfile1.c及map_normalfile2.c。编译两个程序，可执行文件分别为map_normalfile1及map_normalfile2。两个程序通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。map_normalfile2试图打开命令行参数指定的一个普通文件，把该文件映射到进程的地址空间，并对映射后的地址空间进行写操作。map_normalfile1把命令行参数指定的文件映射到进程地址空间，然后对映射后的地址空间执行读操作。这样，两个进程通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。</p>
<p>下面是两个程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------map_normalfile1.c-----------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv) <span class="comment">// map a normal file as shared mem:</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  <span class="keyword">char</span> temp;</span><br><span class="line">   </span><br><span class="line">  fd=<span class="built_in">open</span>(argv[<span class="number">1</span>],O_CREAT|O_RDWR|O_TRUNC,<span class="number">00777</span>);</span><br><span class="line">  lseek(fd,<span class="keyword">sizeof</span>(people)*<span class="number">5</span><span class="number">-1</span>,SEEK_SET);</span><br><span class="line">  <span class="built_in">write</span>(fd,<span class="string">""</span>,<span class="number">1</span>);</span><br><span class="line">   </span><br><span class="line">  p_map = (people*) mmap( <span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">        MAP_SHARED,fd,<span class="number">0</span> );</span><br><span class="line">  <span class="built_in">close</span>( fd );</span><br><span class="line">  temp = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>( ( *(p_map+i) ).name, &amp;temp,<span class="number">2</span> );</span><br><span class="line">    ( *(p_map+i) ).age = <span class="number">20</span>+i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">" initialize over \n "</span>)；</span><br><span class="line">  sleep(<span class="number">10</span>);</span><br><span class="line">  munmap( p_map, <span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"umap ok \n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------map_normalfile2.c-----------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)  <span class="comment">// map a normal file as shared mem:</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd,i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  fd=<span class="built_in">open</span>( argv[<span class="number">1</span>],O_CREAT|O_RDWR,<span class="number">00777</span> );</span><br><span class="line">  p_map = (people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">       MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"name: %s age %d;\n"</span>,(*(p_map+i)).name, (*(p_map+i)).age );</span><br><span class="line">  &#125;</span><br><span class="line">  munmap( p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>范例2：父子进程通过匿名映射实现共享内存</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">int</span>  age;</span><br><span class="line">&#125;people;</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  people *p_map;</span><br><span class="line">  <span class="keyword">char</span> temp;</span><br><span class="line">  p_map=(people*)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>,PROT_READ|PROT_WRITE,</span><br><span class="line">       MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child read: the %d people's age is %d\n"</span>,i+<span class="number">1</span>,(*(p_map+i)).age);</span><br><span class="line">    (*p_map).age = <span class="number">100</span>;</span><br><span class="line">    munmap(p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span>); <span class="comment">//实际上，进程终止时，会自动解除映射。</span></span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  temp = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((*(p_map+i)).name, &amp;temp,<span class="number">2</span>);</span><br><span class="line">    (*(p_map+i)).age=<span class="number">20</span>+i;</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"parent read: the first people,s age is %d\n"</span>,(*p_map).age );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"umap\n"</span>);</span><br><span class="line">  munmap( p_map,<span class="keyword">sizeof</span>(people)*<span class="number">10</span> );</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">"umap ok\n"</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考察程序的输出结果，体会父子进程匿名共享内存：</span></span><br><span class="line">child <span class="built_in">read</span>: the <span class="number">1</span> people<span class="number">'</span>s age is <span class="number">20</span></span><br><span class="line">child <span class="built_in">read</span>: the <span class="number">2</span> people<span class="number">'</span>s age is <span class="number">21</span></span><br><span class="line">child <span class="built_in">read</span>: the <span class="number">3</span> people<span class="number">'</span>s age is <span class="number">22</span></span><br><span class="line">child <span class="built_in">read</span>: the <span class="number">4</span> people<span class="number">'</span>s age is <span class="number">23</span></span><br><span class="line">child <span class="built_in">read</span>: the <span class="number">5</span> people<span class="number">'</span>s age is <span class="number">24</span></span><br><span class="line">parent <span class="built_in">read</span>: the first people,s age is <span class="number">100</span></span><br><span class="line">umap</span><br><span class="line">umap ok</span><br></pre></td></tr></table></figure>

<p><strong>另一种 shmget</strong><br>1.创建共享内存shmget</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原型：<span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">返回值:　创建成功，则返回一个非负整数，即共享内存标识；</span><br><span class="line"></span><br><span class="line"> 　　　　　　如果失败，则返回<span class="number">-1.</span></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">　　key:    <span class="comment">//程序需要提供一个参数key，它为共享内存段提供一个外部名。（每个IPC对象都与一个键 即key相关联，然后此键再由内核变换为标识符）。还有一个特殊的键值IPC_PRIVATE, 它用于创建一个只属于该创建进程的新共享内存，通常不会用到；</span></span><br><span class="line">　　</span><br><span class="line">　　<span class="built_in">size</span>: 　 <span class="comment">//以字节为单位指定需要共享的内存容量。</span></span><br><span class="line"> </span><br><span class="line">　　shmflag: <span class="comment">//包含9个比特的权限标志，它们的作用与创建文件时使用的mode标志是一样。由IPC_CREAT定义的一个特殊比特位，同时必须和权限标志按位或才能创建一个新的共享内存段。</span></span><br><span class="line">（注意：若想创建的新IPC结构没有引用具有同一标识符的现有的IPC结构，就要同时指定IPC_CREAT 和 IPC_EXCL；共享内存属IPC中一种，它同样如此）</span><br></pre></td></tr></table></figure>
<p>注:<br>　　权限标志对共享内存非常有用，因为它允许一个进程创建的共享内存可以被共享内存的创建者所拥有的进程写入，同时其它用户创建的进程只能读取共享内存。我们可以利用这个功能来提供一种有效的对数据进行只读访问的方法，通过将数据放共享内存并设置它的权限，就可以避免数据被其他用户修改。</p>
<p> 2.将共享内存端挂载到自己地址空间shmat<br>　　<br>第一次创建共享内存段时，它不能被任何进程访问。要想启动对该内存的访问，必须将其连接到一个进程的地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">该函数原型：<span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span>　</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">　　返回值：调用成功返回挂载的虚拟地址空间起始地址，失败返回NULL</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">　　<span class="keyword">int</span> shmid            <span class="comment">//是由shmget函数返回的共享内存标识。</span></span><br><span class="line"></span><br><span class="line"> 　<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr  <span class="comment">//指定共享内存连接到当前进程中的地址位置，通常为0，表示让系统来选择　　　　　　　　　　共享内存的地址。</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> shmflg　　　　　<span class="comment">//是一组标志位，通常为0。它还可取:SHM_RND,用以决定是否将当前共享内存段连接到指定的shmaddr上。该参数和shm_addr联合使用，用来控制共享内存连接的地址，除非只计划在一种硬件上运行应用程序，否则不要这样指定。填0让操作系统自己选择是更好的方式。</span></span><br><span class="line"></span><br><span class="line">　　SHM_RDONLY单独使用则是指让它使连接的内存段只读，否则以读写方式连接此内存段</span><br></pre></td></tr></table></figure>



<p>　　　　　　　　　　　　<br>3. 与共享内存段分离 shmdt　</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原型：<span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">　　shm_addr: shmat返回的地址指针。</span><br><span class="line"> </span><br><span class="line">　　成功时，返回<span class="number">0</span>，</span><br><span class="line">　　失败时，返回<span class="number">-1.</span></span><br><span class="line"> </span><br><span class="line">NOTE:</span><br><span class="line"> </span><br><span class="line">　　仅仅是共享内存分离但并未删除它，其标识符及其相关数据结构都在；直到某个进程的IPC_RMID命令的调用shmctl特地删除它为止　　</span><br><span class="line">　　只是使得该共享内存对当前进程不再可用。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>shmctl 共享内存控制函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    原型： <span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span></span><br><span class="line">参数：　</span><br><span class="line"></span><br><span class="line">　　shm_id : 是shmget返回的共享内存标识符。</span><br><span class="line"> </span><br><span class="line">　　cmd: 它可以取<span class="number">3</span>个值:</span><br><span class="line">　　　　IPC_STAT  把shmid_ds结构中的数据设置为共享内存的当前关联值</span><br><span class="line">　　　　IPC_SET   如果进程有足够的权限就把共享内存的当前关联值设置为shmid_ds结构中给出的值</span><br><span class="line">　　　　IPC_RMID  删除共享内存段</span><br><span class="line"> </span><br><span class="line">　　buf:是一个指针，包含共享内存模式和访问权限的结构。</span><br><span class="line"> </span><br><span class="line">　　buf指向的shmid_ds结构体 一定要包含下列一些参数：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span>  </span><br><span class="line">      <span class="keyword">uid_t</span> shm_perm.uid;  </span><br><span class="line">      <span class="keyword">uid_t</span> shm_perm.gid;  </span><br><span class="line">      <span class="keyword">mode_t</span> shm_perm.mode;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>简单使用</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write.c </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Stu s;</span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, <span class="string">"jack"</span>);</span><br><span class="line">    <span class="comment">//创建共享内存段</span></span><br><span class="line">    <span class="keyword">int</span> id = shmget(<span class="number">1234</span>, <span class="number">8</span>, IPC_CREAT|<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>( id == <span class="number">-1</span>)perror( <span class="string">" shmget"</span>),<span class="built_in">exit</span>( <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//挂载到进程的地址空间</span></span><br><span class="line">    Stu* p = ( Stu*)shmat( id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        s.age = i++;</span><br><span class="line">        <span class="built_in">memcpy</span>(p, &amp;s, <span class="keyword">sizeof</span>(Stu));  <span class="comment">//写到共享段中</span></span><br><span class="line">        sleep( <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//read.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;Stu;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> id = shmget(<span class="number">1234</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( id == <span class="number">-1</span>)perror( <span class="string">" shmget"</span>),<span class="built_in">exit</span>( <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Stu* p = ( Stu*)shmat( id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" age= %d, name= %s\n"</span>, p-&gt;age, p-&gt;name);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/" rel="tag">面试必看</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/">面试必看</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-process-and-thread" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/08/process-and-thread/" class="article-date">
  	<time datetime="2018-09-08T07:19:46.000Z" itemprop="datePublished">2018-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/process-and-thread/">
        process and thread
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>转载：<a href="https://my.oschina.net/cnyinlinux/blog/422207" target="_blank" rel="noopener">https://my.oschina.net/cnyinlinux/blog/422207</a><br>这个博客挺厉害的</p>
<hr>
<h2 id="进程和线程的定义"><a href="#进程和线程的定义" class="headerlink" title="进程和线程的定义"></a>进程和线程的定义</h2><p>每一个任务(进程)被创建时，系统会为他分配存储空间等必要资源，然后在内核管理区为该进程创建管理节点，以便后来控制和调度该任务的执行。<br>进程真正进入执行阶段，还需要获得CPU的使用权，这一切都是操作系统掌管着，也就是所谓的调度，在各种条件满足(资源与CPU使用权均获得)的情况下，启动进程的执行过程。<br>除CPU而外，一个很重要的资源就是存储器了，系统会为每个进程分配独有的存储空间，当然包括它特别需要的别的资源，比如写入时外部设备是可使用状态等等。有了上面的引入，我们可以对进程做一个简要的总结：</p>
<blockquote>
<p><strong>进程，是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。它的执行需要系统分配资源创建实体之后，才能进行。</strong></p>
</blockquote>
<blockquote>
<p>随着技术发展，<strong>在执行一些细小任务时，本身无需分配单独资源时(多个任务共享同一组资源即可，比如所有子进程共享父进程的资源)，进程的实现机制依然会繁琐的将资源分割，这样造成浪费，而且还消耗时间。后来就有了专门的多任务技术被创造出来——线程。</strong> (这就是线程必要的关键)</p>
</blockquote>
<p><strong>线程的特点</strong>就是在不需要独立资源的情况下就可以运行。如此一来会极大节省资源开销，以及处理时间。</p>
<h2 id="二者的相同点"><a href="#二者的相同点" class="headerlink" title="二者的相同点"></a>二者的相同点</h2><p>无论是进程还是线程，对于程序员而言，都是用来实现多任务并发的技术手段。二者都可以独立调度，因此在多任务环境下，功能上并无差异。并且二者都具有各自的实体，是系统独立管理的对象个体。所以在系统层面，都可以通过技术手段实现二者的控制。而且二者所具有的状态都非常相似。而且，在多任务程序中，<strong>子进程(子线程)的调度一般与父进程(父线程)平等竞争。</strong><br>其实在Linux内核2.4版以前，线程的实现和管理方式就是完全按照进程方式实现的。在2.6版内核以后才有了单独的线程实现。<br><img src="process-and-thread/process3.jpg" alt="进程的状态转换"></p>
<h2 id="实现方式的差异"><a href="#实现方式的差异" class="headerlink" title="实现方式的差异"></a>实现方式的差异</h2><blockquote>
<p><strong>进程是资源分配的基本单位，线程是调度的基本单位。</strong></p>
</blockquote>
<p>这句经典名言已流传数十年，各种操作系统教材都可见此描述。确实如此，这就是二者的显著区别。读者请注意“基本”二字。相信有读者看到前半句的时候就在心里思考，“进程岂不是不能调度？”，非也！进程和线程都可以被调度，否则多进程程序该如何运行呢！<br>只是，线程是更小的可以调度的单位，也就是说，只要达到线程的水平就可以被调度了，进程自然可以被调度。它强调的是分配资源时的对象必须是进程，不会给一个线程单独分配系统管理的资源。若要运行一个任务，想要获得资源，最起码得有进程，其他子任务可以以线程身份运行，资源共享就行了。<br>    简而言之，<br>    &gt; <strong>进程的个体间是完全独立的，而线程间是彼此依存的。多进程环境中，任何一个进程的终止，不会影响到其他进程。而多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。而任何一个子线程终止一般不会影响其他线程，除非子线程执行了exit()系统调用。任何一个子线程执行exit()，全部线程同时灭亡。</strong></p>
<p>其实，也没有人写出只有线程而没有进程的程序。多线程程序中至少有一个主线程，而这个主线程其实就是有main函数的进程。它是整个程序的进程，所有线程都是它的子线程。我们通常把具有多线程的主进程称之为主线程。<br>从系统实现角度讲，进程的实现是调用fork系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>线程的实现是调用clone系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *child_stack, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，fork()是将父进程的全部资源复制给了子进程。而线程的clone只是复制了一小部分必要的资源。在调用clone时可以通过参数控制要复制的对象。可以说，fork实现的是clone的加强完整版。当然，后来操作系统还进一步优化fork实现——写时复制技术。在子进程需要复制资源(比如子进程执行写入动作更改父进程内存空间)时才复制，否则创建子进程时先不复制。<br>实际中，编写多进程程序时采用fork创建子进程实体。而创建线程时并不采用clone系统调用，而是采用线程库函数。常用线程库有Linux-Native线程库和POSIX线程库。其中应用最为广泛的是POSIX线程库。因此读者在多线程程序中看到的是pthread_create而非clone。<br>我们知道，库是建立在操作系统层面上的功能集合，因而它的功能都是操作系统提供的。由此可知，线程库的内部很可能实现了clone的调用。不管是进程还是线程的实体，都是操作系统上运行的实体。<br>    最后，我们说一下vfork() 。这也是一个系统调用，用来创建一个新的进程。它创建的进程并不复制父进程的资源空间，而是共享，也就说实际上vfork实现的是一个接近线程的实体，只是以进程方式来管理它。并且，vfork()的子进程与父进程的运行时间是确定的：子进程“结束”后父进程才运行。请读者注意<strong>“结束”</strong>二字。并非子进程完成退出之意，而是子进程返回时。一般采用vfork()的子进程，都会紧接着执行execv启动一个全新的进程，该进程的进程空间与父进程完全独立不相干，所以不需要复制父进程资源空间。此时，execv返回时父进程就认为子进程“结束”了，自己开始运行。实际上子进程继续在一个完全独立的空间运行着。<strong>举个例子，比如在一个聊天程序中，弹出了一个视频播放器。你说视频播放器要继承你的聊天程序的进程空间的资源干嘛？莫非视频播放器想要窥探你的聊天隐私不成？懂了吧！</strong></p>
<h2 id="多任务程序设计模式的区别"><a href="#多任务程序设计模式的区别" class="headerlink" title="多任务程序设计模式的区别"></a>多任务程序设计模式的区别</h2><p>由于进程间是独立的，所以在设计多进程程序时，需要做到资源独立管理时就有了天然优势，而线程就显得麻烦多了。比如多任务的TCP程序的服务端，父进程执行accept()一个客户端连接请求之后会返回一个新建立的连接的描述符DES，此时如果fork()一个子进程，将DES带入到子进程空间去处理该连接的请求，父进程继续accept等待别的客户端连接请求，这样设计非常简练，而且父进程可以用同一变量(val)保存accept()的返回值，因为子进程会复制val到自己空间，父进程再覆盖此前的值不影响子进程工作。但是如果换成多线程，父线程就不能复用一个变量val多次执行accept()了。因为子线程没有复制val的存储空间，而是使用父线程的，如果子线程在读取val时父线程接受了另一个客户端请求覆盖了该值，则子线程无法继续处理上一次的连接任务了。改进的办法是子线程立马复制val的值在自己的栈区，但父线程必须保证子线程复制动作完成之后再执行新的accept()。但这执行起来并不简单，因为子线程与父线程的调度是独立的，父线程无法知道子线程何时复制完毕。这又得发生线程间通信，子线程复制完成后主动通知父线程。这样一来父线程的处理动作必然不能连贯，比起多进程环境，父线程显得效率有所下降。<br><strong>PS：这里引述一个知名的面试问题：多进程的TCP服务端，能否互换fork()与accept()的位置？请读者自行思考。</strong><br>关于资源不独立，看似是个缺点，但在有的情况下就成了优点。多进程环境间完全独立，要实现通信的话就得采用进程间的通信方式，它们通常都是耗时间的。而线程则不用任何手段数据就是共享的。当然多个子线程在同时执行写入操作时需要实现互斥，否则数据就写“脏”了。</p>
<h2 id="控制方式的异同"><a href="#控制方式的异同" class="headerlink" title="控制方式的异同"></a>控制方式的异同</h2><p>进程与线程的身份标示ID管理方式不一样，<strong>进程的ID为pid_t类型，实际为一个int型的变量</strong>(也就是说是有限的)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/unistd.h:<span class="number">260</span>: <span class="keyword">typedef</span> <span class="keyword">__pid_t</span>   <span class="keyword">pid_t</span>;</span><br><span class="line">/usr/include/bits/types.h:<span class="number">126</span>: <span class="meta"># <span class="meta-keyword">define</span> __STD_TYPE    typedef</span></span><br><span class="line">/usr/include/bits/types.h:<span class="number">142</span>:__STD_TYPE  __PID_T_TYPE   <span class="keyword">__pid_t</span>;</span><br><span class="line">/usr/include/bits/typesizes.h:<span class="number">53</span>:<span class="meta">#<span class="meta-keyword">define</span> __PID_T_TYPE   __S32_TYPE</span></span><br><span class="line">/usr/include/bits/types.h:<span class="number">100</span>:<span class="meta">#<span class="meta-keyword">define</span>   __S32_TYPE      int</span></span><br></pre></td></tr></table></figure>
<p>在全系统中，进程ID是唯一标识，对于进程的管理都是通过PID来实现的。每创建一个进程，内核去中就会创建一个结构体来存储该进程的全部信息：<br>注：下述代码来自 Linux内核3.18.1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include/linux/sched.h:<span class="number">1235</span>:<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">        <span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">pid_t</span> tgid;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个存储进程信息的节点也都保存着自己的PID。需要管理该进程时就通过这个ID来实现(比如发送信号)。当子进程结束要回收时(子进程调用exit()退出或代码执行完)，需要通过wait()系统调用来进行，未回收的消亡进程会成为僵尸进程，其进程实体已经不复存在，但会虚占PID资源，因此回收是有必要的。<br><strong>线程的ID是一个long型变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/bits/pthreadtypes.h:<span class="number">60</span>:<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br></pre></td></tr></table></figure>
<p>它的范围大得多，管理方式也不一样。线程ID一般在本进程空间内作用就可以了，当然系统在管理线程时也需要记录其信息。其方式是，在内核创建一个内核态线程与之对应，也就是说每一个用户创建的线程都有一个内核态线程对应。但这种对应关系不是一对一，而是多对一的关系，也就是一个内核态线程可以对应着多个用户级线程。还是请读者参看《Linux线程的实质》普及相关概念。此处贴出blog地址：<br><a href="http://my.oschina.net/cnyinlinux/blog/367910" target="_blank" rel="noopener">http://my.oschina.net/cnyinlinux/blog/367910</a><br>对于线程而言，若要主动终止需要调用pthread_exit() ，主线程需要调用pthread_join()来回收(前提是该线程没有被detached，相关概念请查阅线程的“分离属性”)。像线发送线程信号也是通过线程ID实现的。</p>
<h2 id="资源管理方式的异同"><a href="#资源管理方式的异同" class="headerlink" title="资源管理方式的异同"></a>资源管理方式的异同</h2><p>进程本身是资源分配的基本单位，因而它的资源都是独立的，如果有多进程间的共享资源，就要用到<strong>进程间的通信</strong>方式了，比如<strong>共享内存</strong>。共享数据就放在共享内存去，大家都可以访问，为保证数据写入的安全，加上<strong>信号量</strong>一同使用。一般而言，<strong>共享内存都是和信号量一起使用</strong>。<strong>消息队列</strong>则不同，由于消息的收发是原子操作，因而自动实现了互斥，单独使用就是安全的。<br>线程间要使用共享资源不需要用共享内存，直接使用全局变量即可，或者malloc()动态申请内存。显得方便直接。而且互斥使用的是同一进程空间内的互斥量，所以效率上也有优势。<br>实际中，为了使程序内资源充分规整，也都采用共享内存来存储核心数据。不管进程还是线程，都采用这种方式。原因之一就是，共享内存是脱离进程的资源，如果<strong>进程发生意外终止的话，共享内存可以独立存在不会被回收</strong>(是否回收由用户编程实现)。进程的空间在进程崩溃的那一刻也被系统回收了。虽然有coredump机制，但也只能是有限的弥补。共享内存在进程down之后还完整保存，这样可以拿来分析程序的故障原因。同时，<strong>运行的宝贵数据没有丢失，程序重启之后还能继续处理之前未完成的任务</strong>，这也是采用共享内存的又一大好处。<br>总结之，进程间的通信方式都是脱离于进程本身存在的，是全系统都可见的。这样一来，进程的单点故障并不会损毁数据，当然这不一定全是优点。比如，<strong>进程崩溃前对信号量加锁，崩溃后重启，然后再次进入运行状态，此时直接进行加锁，可能造成死锁，程序再也无法继续运转。</strong>再比如，<strong>共享内存是全系统可见的，如果你的进程资源被他人误读误写，后果肯定也是你不想要的。</strong>所以，各有利弊，关键在于程序设计时如何考量，技术上如何规避。这说起来又是编程技巧和经验的事情了。</p>
<h2 id="个体间辈分关系的迥异"><a href="#个体间辈分关系的迥异" class="headerlink" title="个体间辈分关系的迥异"></a>个体间辈分关系的迥异</h2><p>进程的备份关系森严，在父进程没有结束前，所有的子进程都尊从父子关系，也就是说A创建了B，则A与B是父子关系，B又创建了C，则B与C也是父子关系，A与C构成爷孙关系，也就是说C是A的孙子进程。在系统上使用pstree命令打印进程树，可以清晰看到备份关系。<br>多线程间的关系没有那么严格，不管是父线程还是子线程创建了新的线程，都是共享父线程的资源，所以，都可以说是父线程的子线程，也就是只存在一个父线程，其余线程都是父线程的子线程。</p>
<h2 id="进程池与线程池的技术实现差别"><a href="#进程池与线程池的技术实现差别" class="headerlink" title="进程池与线程池的技术实现差别"></a>进程池与线程池的技术实现差别</h2><p>我们都知道，进程和线程的创建时需要时间的，并且系统所能承受的进程和线程数也是有上限的，这样一来，如果业务在运行中需要动态创建子进程或线程时，系统无法承受不能立即创建的话，必然影响业务。综上，聪明的程序员发明了一种新方法——池。<br>在程序启动时，就预先创建一些子进程或线程，这样在需要用时直接使唤。这就是老人口中的“多生孩子多种树”。程序才开始运行，没有那么多的服务请求，必然大量的进程或线程空闲，这时候一般让他们“冬眠”，这样不耗资源，要不然一大堆孩子的口食也是个负担啊。对于进程和线程而言，方式是不一样的。另外，当你有了任务，要分配给那些孩子的时候，手段也不一样。下面就分别来解说。<br><strong>进程池</strong><br>首先创建了一批进程，就得管理，也就是你得分开保存进程ID，可以用数组，也可用链表。建议用数组，这样可以实现常数内找到某个线程，而且既然做了进程池，就预先估计好了生产多少进程合适，一般也不会再动态延展。就算要动态延展，也能预估范围，提前做一个足够大的数组。不为别的，就是为了快速响应。本来错进程池的目的也是为了效率。<br>接下来就要让闲置进程冬眠了，<strong>可以让他们pause()挂起，也可用信号量挂起，还可以用IPC阻塞</strong>，方法很多，分析各自优缺点根据实际情况采用就是了。<br>然后是分配任务了，当你有任务的时候就要让他干活了。唤醒了进程，让它从哪儿开始干呢？肯定得用到进程间通信了，比如信号唤醒它，然后让它在预先指定的地方去读取任务，可以用函数指针来实现，要让它干什么，就在约定的地方设置代码段指针。这也只是告诉了它怎么干，还没说干什么(数据条件)，再通过共享内存把要处理的数据设置好，这也子进程就知道怎么做了。干完之后再来一次进程间通信然后自己继续冬眠，父进程就知道孩子干完了，收割成果。<br>最后结束时回收子进程，向各进程发送信号唤醒，改变激活状态让其主动结束，然后逐个wait()就可以了。<br><strong>线程池</strong><br>线程池的思想与上述类似，只是它更为轻量级，所以调度起来不用等待额外的资源。<br>要让线程阻塞，用条件变量就是了，需要干活的时候父线程改变条件，子线程就被激活。<br>线程间通信方式就不用赘述了，不用繁琐的通信就能达成，比起进程间效率要高一些。<br>线程干完之后自己再改变条件，这样父线程也就知道该收割成果了。<br>整个程序结束时，逐个改变条件并改变激活状态让子线程结束，最后逐个回收即可。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/" rel="tag">面试必看</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/">面试必看</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-process-status" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/08/process-status/" class="article-date">
  	<time datetime="2018-09-08T06:40:01.000Z" itemprop="datePublished">2018-09-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/08/process-status/">
        process-status
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p>转载：<a href="http://gityuan.com/2015/12/12/android-process-manage/" target="_blank" rel="noopener">http://gityuan.com/2015/12/12/android-process-manage/</a></p>
<hr>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程的生命周期内，有5种状态，分别为new, runnable, running, blocked, dead共5种状态，进程所处的状态，会随着系统负载以及运行环境的变化而不断发生改变(由一个状态切换到另一个状态)。</p>
<p><img src="process-status/process1.jpg" alt="状态1"></p>
<blockquote>
<ul>
<li>创建状态(new)：进程正在被创建，仅仅在堆上分配内存，尚未进入就绪状态；</li>
<li>就绪状态(Runnable)：进程已处于准备运行的状态，即进程已获得除了CPU之外的所需资源，一旦分配到CPU时间片即可进入运行状态。</li>
<li>运行状态(Running)：进程正在运行，占用CPU资源，执行代码。任意时刻点，处于运行状态的进程(线程)的总数，不会超过是CPU的总核数；</li>
<li>阻塞状态(Blocked): 进程处于等待某一事件而放弃CPU，暂停运行。阻塞状态分3类：<blockquote>
<ul>
<li>阻塞在对象等待池：当进程在运行时执行Object.wait()方法，虚拟机会把线程放入等待池；</li>
<li>阻塞在对象锁池：当进程在运行时企图获取已经被其他进程占用的同步锁时，虚拟机会把线程放入锁池；</li>
<li>其他阻塞状态 ：当进程在运行时执行Sleep()方法，或调用其他进程的join()方法，或者发出I/O请求时，进入该阻塞状态。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>死亡状态(dead)：进程正在被结束，这可能是进程正常结束或其他原因中断退出运行。<blockquote>
<ul>
<li>进程结束运行前，系统必须置进程为dead态，再处理资源释放和回收等工作。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p><img src="process-status/process2.jpg" alt="状态2"> <img src="process-status/process3.jpg" alt="状态3"></p>
<blockquote>
<ol>
<li>Runnable -&gt; Running： 就绪态的进程获得了CPU的时间片，进入运行态；</li>
<li>Running -&gt; Runnable: 运行态的进程在时间片用完后，必须出让CPU，进入就绪态；</li>
<li>Running -&gt; Blocked： 当进程请求资源的使用权(如外设)或等待事件发生(如I/O完成)时，由运行态转换为阻塞态；</li>
<li>Blocked -&gt; Runnable： 当进程已经获取所需资源的使用权或者等待事件已完成时，中断处理程序必须把相应进程的状态由阻塞态转为就绪态；</li>
</ol>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>进程的状态转移，主要围绕Runnable、Running、Blocked三个状态。Runnable与Running之间的转换，更多的是与调度器Scheduler相关，而Blocked状态主要涉及资源的使用权问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/" rel="tag">面试必看</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/">面试必看</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-list-tuple-dict-set" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/05/list-tuple-dict-set/" class="article-date">
  	<time datetime="2018-09-05T02:14:48.000Z" itemprop="datePublished">2018-09-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/05/list-tuple-dict-set/">
        list, tuple, dict, set
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="python中列表-list-，元组-tuple-，字典-dict-，集合-set-的区别"><a href="#python中列表-list-，元组-tuple-，字典-dict-，集合-set-的区别" class="headerlink" title="python中列表(list)，元组(tuple)，字典(dict)，集合(set)的区别"></a>python中列表(list)，元组(tuple)，字典(dict)，集合(set)的区别</h1><p>Django 整理</p>
<hr>
<h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h2><p>1.任意对象的有序集合<br>列表是一组任意类型的值，按照一定顺序组合而成的<br>2.通过偏移读取<br>组成列表的值叫做元素(Elements)。每一个元素被标识一个索引，第一个索引是0，序列的功能都能实现<br>3.<strong>可变长度，异构以及任意嵌套</strong><br>列表中的元素可以是任意类型，甚至是列表类型，也就是说列表可以嵌套<br>4.<strong>可变的序列</strong><br>支持索引、切片、合并、删除等等操作，它们都是在原处进行修改列表<br>5.对象引用数组<br>列表可以当成普通的数组，每当用到引用时，Python总是会将这个引用指向一个对象，所以程序只需处理对象的操作。当把一个对象赋给一个数据结构元素或变量名时，Python总是会存储对象的引用，而不是对象的一个拷贝。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可用list()函数建立</span></span><br><span class="line">list1 = list((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 用[]建立，可包含不同数据类型</span></span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="string">'hello'</span>, <span class="number">3.5</span>]</span><br><span class="line"><span class="comment"># 可用下标访问</span></span><br><span class="line">print(list1[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">print(list2[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="number">3</span>, <span class="string">'hello'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="list-方法"><a href="#list-方法" class="headerlink" title="list 方法"></a>list 方法</h3><blockquote>
<p>操作     解释<br>list.append():     追加成员<br>list.count(x):     计算列表中参数x出现的次数<br>list.extend(L):     向列表中追加另一个列表L<br>list.index(x):     获得参数x在列表中的位置<br>list.insert():     向列表中插入数据<br>list.pop():     删除列表中的成员（通过下标删除）<br>list.remove():     删除列表中的成员（直接删除）<br>list.reverse():     将列表中成员的顺序颠倒<br>list.sort():     将列表中成员排序</p>
</blockquote>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h2><p>1.任意对象的有序集合<br>与列表相同<br>2.通过偏移存取<br>与列表相同<br>3.属于不可变序列类型<br>类似于字符串，但元组是不可变的，不支持在列表中任何原处修改操作，不支持任何方法调用<br>4.<strong>固定长度、异构、任意嵌套</strong><br>固定长度即元组不可变，在不被拷贝的情况下长度固定，其他同列表<br>5.对象引用的数组<br>与列表相似，元祖是对象引用的数组</p>
<p>和list相比<br>1.比列表操作速度快<br>2.对数据“写保护“<br>3.可用于字符串格式化中<br>4.可作为字典的key</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可用tuple()函数创建</span></span><br><span class="line">tuple1 = tuple([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 用()建立，可包含不同数据类型</span></span><br><span class="line">tuple2 = (<span class="number">1</span>, <span class="number">3</span>, <span class="string">'hello'</span>, <span class="number">3.5</span>)</span><br><span class="line"><span class="comment"># 可用下标访问</span></span><br><span class="line">print(tuple1[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 可切片</span></span><br><span class="line">print(tuple2[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 不可以修改元素</span></span><br><span class="line">tuple1[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">'hello'</span>)</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<h3 id="tuple-方法"><a href="#tuple-方法" class="headerlink" title="tuple 方法"></a>tuple 方法</h3><blockquote>
<p>操作     解释<br>cmp(tuple1, tuple2)     比较两个元组元素。<br>len(tuple)     计算元组元素个数。<br>max(tuple)     返回元组中元素最大值。<br>min(tuple)     返回元组中元素最小值。<br>tuple(seq)     将列表转换为元组。</p>
</blockquote>
<h2 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 (dict)"></a>字典 (dict)</h2><p>1.通过键而不是偏移量来读取<br>字典就是一个关联数组，是一个通过关键字索引的对象的集合，使用键-值（key-value）进行存储，查找速度快<br>2.任意对象的无序集合<br>字典中的项没有特定顺序，以“键”为象征<br>3.可变长、异构、任意嵌套<br>同列表，嵌套可以包含列表和其他的字典等<br>4.属于可变映射类型<br>因为是无序，故不能进行序列操作，但可以在远处修改，通过键映射到值。字典是唯一内置的映射类型（键映射到值的对象）<br>5.对象引用表<br>字典存储的是对象引用，不是拷贝，和列表一样。字典的key是不能变的，list不能作为key，字符串、元祖、整数等都可以</p>
<p><strong>和list比较</strong>，dict有以下几个特点：<br>1<strong>.查找和插入的速度极快，不会随着key的增加而增加</strong><br>2.<strong>需要占用大量的内存，内存浪费多</strong><br>而list相反：<br>1.查找和插入的时间随着元素的增加而增加<br>2.占用空间小，浪费内存很少<br>所以，<strong>dict是用空间来换取时间的一种方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用dict()函数创建</span></span><br><span class="line">dict1 = dict([(<span class="string">'name'</span>, <span class="string">'kyda'</span>), (<span class="string">'e'</span>, <span class="number">10</span>)])</span><br><span class="line"><span class="comment"># 用&#123;&#125;创建</span></span><br><span class="line">dict2 = &#123;<span class="string">'name'</span>: <span class="string">'lin'</span>, <span class="string">'age'</span>: <span class="number">21</span>&#125;</span><br><span class="line">print(dict1)</span><br><span class="line"><span class="comment"># 使用键（key）来访问元素</span></span><br><span class="line">print(dict2[<span class="string">'name'</span>])</span><br><span class="line"><span class="comment"># 使用键（key）来访问元素，并修改元素的值</span></span><br><span class="line">dict2[<span class="string">'age'</span>] = <span class="number">23</span></span><br><span class="line">print(dict2)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">'hello'</span>)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'kyda'</span>, <span class="string">'age'</span>: <span class="number">10</span>&#125;</span><br><span class="line">lin</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'lin'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dict-方法"><a href="#dict-方法" class="headerlink" title="dict 方法"></a>dict 方法</h3><blockquote>
<p>操作     解释<br>adict.keys()     返回一个包含字典所有KEY的列表；<br>adict.values()     返回一个包含字典所有value的列表；<br>adict.items()     返回一个包含所有（键，值）元祖的列表；<br>adict.clear()     删除字典中的所有项或元素；<br>adict.copy()     返回一个字典浅拷贝的副本；<br>adict.fromkeys(seq, val=None)     创建并返回一个新字典，以seq中的元素做该字典的键，val做该字典中所有键对应的初始值（默认为None）；<br>adict.get(key, default = None)     返回字典中key对应的值，若key不存在字典中，则返回default的值（default默认为None）；<br>adict.has_key(key)     如果key在字典中，返回True，否则返回False。 现在用 in 、 not in；<br>adict.iteritems() adict.iterkeys() adict.itervalues()     与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表；<br>adict.pop(key[,default])     和get方法相似。如果字典中存在key，删除并返回key对应的vuale；如果key不存在，且没有给出default的值，则引发keyerror异常；<br>adict.setdefault(key, default=None)     和set()方法相似，但如果字典中不存在Key键，由 adict[key] = default 为它赋值；<br>adict.update(bdict)     将字典bdict的键值对添加到字典adict中。</p>
</blockquote>
<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h2><p>1.是一组key的集合，但不存储value，并且key不能重复<br>创建一个set，需要提供一个list作为输入集合,s = set([1,2,3]),注意，传入的参数 [1, 2, 3] 是一个list，而显示的 set([1, 2, 3]) 只是告诉你这个set内部有1，2，3这3个元素，显示的[ ]不表示这是一个list<br>2.重复元素在set中自动被过滤<br>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作</p>
<p>还有一种集合是forzenset( )，是冻结的集合，它是不可变的，存在哈希值，好处是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add，remove方法</p>
<p>和dict对比<br>1.set和dict的唯一区别仅在于<strong>没有存储对应的value</strong><br>2.set的原理和dict一样，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部<strong>“不会有重复元素”</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两种方法创建</span></span><br><span class="line">set1 = set(<span class="string">'kydaa'</span>)</span><br><span class="line">set2 = &#123;<span class="string">'abc'</span>, <span class="string">'jaja'</span>, <span class="string">'abc'</span>, <span class="string">'kyda'</span>&#125;</span><br><span class="line">print(set1)</span><br><span class="line">print(set2)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'y'</span>, <span class="string">'d'</span>, <span class="string">'k'</span>&#125;</span><br><span class="line">&#123;<span class="string">'jaja'</span>, <span class="string">'abc'</span>, <span class="string">'kyda'</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法:"></a>set方法:</h3><blockquote>
<p>操作     解释<br>s.issubset(t)，s &lt;= t     测试是否 s 中的每一个元素都在 t 中<br>s.issuperset(t)，s &gt;= t     测试是否 t 中的每一个元素都在 s 中<br>s.union(t)，s | t     返回一个新的 set 包含 s 和 t 中的每一个元素<br>s.intersection(t)，s &amp; t     返回一个新的 set 包含 s 和 t 中的公共元素<br>s.difference(t),s - t     返回一个新的 set 包含 s 中有但是 t 中没有的元素<br>s.symmetric_difference(t),s ^ t     返回一个新的 set 包含 s 和 t 中不重复的元素<br>s.copy()     返回 set “s”的一个浅复制</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h3><p>列表和元组有很多相似的地方，操作也差不多。不过<strong>列表是可变序列，元组为不可变序列</strong>。也就是说列表主要用于对象长度不可知的情况下，而元组用于对象长度已知的情况下，而且<strong>元组元素一旦创建变就不可修改</strong>。<br>例如我们在打开一个文本时，并不知道里面有多少行文字，所以用列表来保存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readlines())</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># ['hello world\n', 'hi kyda\n', 'this is my program']</span></span><br></pre></td></tr></table></figure>
<p> 而我们在储存一个人的信息（名字，年龄，性别，假定只需要这三种信息，所以对象长度为3）的时候，就可以用元组来实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id = (<span class="string">'kyda'</span>, <span class="number">19</span>, <span class="string">'man'</span>)</span><br><span class="line">print(id)</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># ('kyda', 19, 'man')</span></span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典主要应用于需要对元素进行标记的对象，这样在使用的时候便不必记住元素列表中或者元组中的位置，只需要利用键来进行访问对象中相应的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id = &#123;<span class="string">'name'</span>: <span class="string">'kyda'</span>, <span class="string">'age'</span>: <span class="number">19</span>, ‘sex<span class="string">': '</span>man<span class="string">')</span></span><br><span class="line"><span class="string">print(id['</span>age<span class="string">'])</span></span><br><span class="line"><span class="string"># 结果：</span></span><br><span class="line"><span class="string"># 19</span></span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合中的元素不可重复的特点使它被拿来去重。比如我在爬去糗事百科全站的文章链接(存放与列表中）的时候，不可避免的会遇到重复的链接。这是我们只需将列表转换为集合便能有效的去除重复部分。<br>比如上面的例程。</p>
<p>在海量数据中查找元素时，最好将数据创建为字典，或者是集合</p>
<p>这是由于字典和集合背后的查找原理是散列（哈希）表。由于散列表在查找元素时的时间复杂度基本是O(1),这使查找时间很短。</p>
<h2 id="灵活运用推导来创建"><a href="#灵活运用推导来创建" class="headerlink" title="灵活运用推导来创建"></a>灵活运用推导来创建</h2><p>推导可以说是python最灵活的特性之一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list </span></span><br><span class="line">list1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line"><span class="comment"># 用双重推导（笛卡尔积）来创建</span></span><br><span class="line">list1 = [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>]</span><br><span class="line">list2 = [<span class="string">'kyda'</span>, <span class="number">19</span>, <span class="string">'man'</span>]</span><br><span class="line">ID = &#123;x: y <span class="keyword">for</span> x <span class="keyword">in</span> list1 <span class="keyword">for</span> y <span class="keyword">in</span> list2&#125;</span><br><span class="line">print(ID)</span><br><span class="line"><span class="comment"># &#123;'name': 'man', 'age': 'man', 'sex': 'man'&#125;</span></span><br><span class="line"><span class="comment"># 还可以运用zip()函数简化</span></span><br><span class="line">ID = &#123;x: y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(list1, list2)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表和元组也可以运用双重推导（笛卡尔积）来创建。比如我们要生成一个二维坐标数组：</span></span><br><span class="line">coordinate = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">print(coordinate)</span><br><span class="line"><span class="comment"># [(0, 0), (0, 1), (1, 0), (1, 1)]</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举元素"><a href="#枚举元素" class="headerlink" title="枚举元素"></a>枚举元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于列表， 集合，集合都可以运用for…in…来进行枚举</span></span><br><span class="line">set1 = &#123;<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> set1:</span><br><span class="line">    print(tmp)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line"><span class="comment"># age</span></span><br><span class="line"><span class="comment"># sex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有时候，我们需要用到元素的索引：</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> set1:</span><br><span class="line">    print(tmp, index)</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#  这样写太过于冗余，我可以用enumerate()函数来帮组我们实现：</span></span><br><span class="line"><span class="keyword">for</span> index, tmp <span class="keyword">in</span> enumerate(set1):</span><br><span class="line">    print(tmp, index)</span><br></pre></td></tr></table></figure>
<p> 而对于字典，我们要枚举时就有点麻烦。不过还好，字典的方法中有三个方法帮助我们解决这个问题：</p>
<blockquote>
<p>操作     解释<br>adict.keys()     返回一个包含字典所有KEY的列表；<br>adict.values()     返回一个包含字典所有value的列表；<br>adict.items()     返回一个包含所有（键，值）元祖的列表；</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ist1 = [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>]</span><br><span class="line">list2 = [<span class="string">'kyda'</span>, <span class="number">19</span>, <span class="string">'man'</span>]</span><br><span class="line"> </span><br><span class="line">ID = &#123;x: y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(list1, list2)&#125;</span><br><span class="line"><span class="keyword">for</span> tmp <span class="keyword">in</span> ID.items():</span><br><span class="line">    print(tmp)</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># ('age', 19)</span></span><br><span class="line"><span class="comment"># ('sex', 'man')</span></span><br><span class="line"><span class="comment"># ('name', 'kyda')</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/" rel="tag">面试必看</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/pyhton/">pyhton</a><a class="article-category-link" href="/categories/pyhton/django/">django</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-redis-server" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/02/redis-server/" class="article-date">
  	<time datetime="2018-09-02T06:20:04.000Z" itemprop="datePublished">2018-09-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/02/redis-server/">
        redis-server
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="redis-server-简单整理"><a href="#redis-server-简单整理" class="headerlink" title="redis-server 简单整理"></a>redis-server 简单整理</h1><p>转载：<a href="http://www.cnblogs.com/shanyou/archive/2012/01/28/2330451.html" target="_blank" rel="noopener">http://www.cnblogs.com/shanyou/archive/2012/01/28/2330451.html</a><br>转载：<a href="https://zh.wikipedia.org/wiki/Redis" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Redis</a><br>资料主要转载上个博客和维基百科， 博客中用的是redis-2.4.6<br>目前学习的是redis-4.0.9，可能配置有些出入。<br>redis server主要是一个数据存储系统。用来存储数据的。</p>
<hr>
<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p> Redis是一个key-value存储系统。和Memcached类似，但是解决了断电后数据完全丢失的情况。<br> 支持更多无化的value类型，除了和string外，还支持lists（链表）、sets（集合）和zsets（有序集合）几种<strong>数据类型</strong>。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis的外围由一个键、值映射的字典构成。与其他非关系型数据库主要不同在于：Redis中值的类型不仅限于字符串，还支持如下抽象数据类型：</p>
<blockquote>
<ul>
<li>字符串列表</li>
<li>无序不重复的字符串集合</li>
<li>有序不重复的字符串集合</li>
<li>键、值都为字符串的哈希表</li>
</ul>
</blockquote>
<p>值的类型决定了值本身支持的操作。Redis支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作。</p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>Redis的代码遵循ANSI-C编写，可以在所有POSIX系统（如Linux, *BSD, Mac OS X, Solaris等）上安装运行。而且Redis并不依赖任何非标准库，也没有编译参数必需添加。redis的安装出奇的简单，这可能也是他风靡的一个原因，让人很容易上手，不像某些东西，编译阶段就能让人完全绝望。</p>
<p>先去官网下载源码：<br>wget <a href="http://redis.googlecode.com/files/redis-2.4.6.tar.gz" target="_blank" rel="noopener">http://redis.googlecode.com/files/redis-2.4.6.tar.gz</a></p>
<p>解压：</p>
<blockquote>
<p>tar –zxvf redis-2.4.6.tar.gz</p>
</blockquote>
<p>编译<br>需要说明的事，redis的安装非常简单，已经有现成的Makefile文件，直接运行make命令即可。</p>
<blockquote>
<p>make<br>make install</p>
</blockquote>
<p>Ubuntu 18.04 可以使用：</p>
<blockquote>
<p>sudo pat-get install redis-server</p>
</blockquote>
<p>Redis 由四个可执行文件：<strong>redis-benchmark、redis-cli、redis-server、redis-stat</strong> 这四个文件，加上一个redis.conf就构成了整个redis的最终可用包。它们的作用如下：</p>
<p><strong>redis-server:</strong> Redis服务器的daemon启动程序<br><strong>redis-cli:</strong> Redis命令行操作工具。当然，你也可以用telnet根据其纯文本协议来操作<br><strong>redis-benchmark:</strong> Redis性能测试工具, 测试Redis在你的系统及你的配置下的读写性能<br><strong>redis-stat:</strong> Redis状态检测工具，可以检测Redis当前状态参数及延迟状况<br>现在就可以启动redis了，redis只有一个启动参数，就是他的配置文件路径。</p>
<p>redis-server /etc/redis.conf</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>注意，默认复制过去的redis.conf文件的daemonize参数为no，所以redis不会在后台运行，这时要测试，我们需要重新开一个终端。修改为yes则为后台运行redis。另外配置文件中规定了pid文件，log文件和数据文件的地址，如果有需要先修改，默认log信息定向到stdout.<br>下面是redis.conf的主要配置参数的意义：</p>
<blockquote>
<p>daemonize：是否以后台daemon方式运行<br>pidfile：pid文件位置<br>port：监听的端口号<br>timeout：请求超时时间<br>loglevel：log信息级别<br>logfile：log文件位置<br>databases：开启数据库的数量<br>save * <em>：保存快照的频率，第一个</em>表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。<br>rdbcompression：是否使用压缩<br>dbfilename：数据快照文件名（只是文件名，不包括目录）<br>dir：数据快照的保存目录（这个是目录）<br>appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。<br>appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）</p>
</blockquote>
<p>这时你可以打开一个终端进行测试了，配置文件中默认的监听端口是6379</p>
<h2 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h2><p>redis 的作者antirez曾称其为一个数据结构服务器（data structures server），这是一个非常准确的表述，redis的所有功能就是将数据以其固有的几种结构保存，并提供给用户操作这几种结构的接口。我们可以想象我们在各种语言中的那些固有数据类型及其操作。</p>
<p>redis目前提供<strong>四种数据类型</strong>：string,list,set及zset(sorted set)和Hash。</p>
<blockquote>
<ul>
<li>string是最简单的类型，你可以理解成与Memcached一模一个的类型，一个key对应一个value，其上支持的操作与Memcached的操作类似。但它的功能更丰富。</li>
<li>list是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等。操作中key理解为链表的名字。</li>
<li>set是集合，和我们数学中的集合概念相似，对集合的操作有添加删除元素，有对多个集合求交并差等操作。操作中key理解为集合的名字。zset是set的一个升级版本，他在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以理解了有两列的mysql表，一列存value，一列存顺序。操作中key理解为zset的名字。</li>
<li>Hash数据类型允许用户用Redis存储对象类型,Hash数据类型的一个重要优点是,当你存储的数据对象只有很少几个key值时,数据存储的内存消耗会很小.更多关于Hash数据类型的说明请见: <a href="http://code.google.com/p/redis/wiki/Hashes" target="_blank" rel="noopener">http://code.google.com/p/redis/wiki/Hashes</a></li>
</ul>
</blockquote>
<p>在官网上给出了所有支持的接口列表，并副副附有详细的介绍，地址：<br><a href="http://code.google.com/p/redis/wiki/CommandReference" target="_blank" rel="noopener">http://code.google.com/p/redis/wiki/CommandReference</a></p>
<h2 id="redis数据存储"><a href="#redis数据存储" class="headerlink" title="redis数据存储"></a>redis数据存储</h2><p>redis的存储分为内存存储、磁盘存储和log文件三部分，配置文件中有三个参数对其进行配置。</p>
<p><strong>save seconds updates，save</strong>配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。</p>
<p><strong>appendonly yes/no ，appendonly</strong> 配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</p>
<p><strong>appendfsync no/always/everysec ，appendfsync</strong> 配置，no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次。</p>
<h2 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h2><p>许多语言都包含Redis支持，包括:</p>
<table>
<thead>
<tr>
<th>ActionScript</th>
<th>C</th>
<th>C++</th>
<th>Clojure</th>
</tr>
</thead>
<tbody><tr>
<td>Common Lisp</td>
<td>Dart</td>
<td>Erlang</td>
<td>Go</td>
</tr>
<tr>
<td>Haskell</td>
<td>Haxe</td>
<td>Io</td>
<td>Java</td>
</tr>
<tr>
<td>Fibjs</td>
<td>Node.js</td>
<td>Lua</td>
<td>Objective-C</td>
</tr>
<tr>
<td>Perl</td>
<td>PHP</td>
<td>Pure Data</td>
<td>Python</td>
</tr>
<tr>
<td>Ruby</td>
<td>Scala</td>
<td>Smalltalk</td>
<td>Tcl</td>
</tr>
<tr>
<td>## Python简单示例</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># lredis-server保持开启状态 如果在客户端设置了密码 添加password=密码即可</span></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line">r = redis.StrictRedis(connection_pool=pool)</span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">r.set(<span class="string">'test'</span>, <span class="string">'aaa'</span>)</span><br><span class="line"><span class="keyword">print</span> r.get(<span class="string">'test'</span>)</span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line"><span class="comment"># 注意python、lrange两个range的范围</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">11</span>):</span><br><span class="line">    r.lpush(<span class="string">'list'</span>, x)</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> r.lrange(<span class="string">'list'</span>, <span class="string">'0'</span>, <span class="string">'10'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 雜湊</span></span><br><span class="line">dict_hash = &#123;<span class="string">'name'</span>: <span class="string">'tang'</span>, <span class="string">'password'</span>: <span class="string">'tang_passwd'</span>&#125;</span><br><span class="line">r.hmset(<span class="string">'hash_test'</span>, dict_hash)</span><br><span class="line"><span class="keyword">print</span> r.hgetall(<span class="string">'hash_test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line">r.sadd(<span class="string">'set_test'</span>, <span class="string">'aaa'</span>, <span class="string">'bbb'</span>)</span><br><span class="line">r.sadd(<span class="string">'set_test'</span>, <span class="string">'ccc'</span>)</span><br><span class="line">r.sadd(<span class="string">'set_test'</span>, <span class="string">'ddd'</span>)</span><br><span class="line"><span class="keyword">print</span> r.smembers(<span class="string">'set_test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序集</span></span><br><span class="line">r.zadd(<span class="string">'zset_test'</span>, <span class="string">'aaa'</span>, <span class="number">1</span>, <span class="string">'bbb'</span>, <span class="number">1</span>)</span><br><span class="line">r.zadd(<span class="string">'zset_test'</span>, <span class="string">'ccc'</span>, <span class="number">1</span>)</span><br><span class="line">r.zadd(<span class="string">'zset_test'</span>, <span class="string">'ddd'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> r.zrange(<span class="string">'zset_test'</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Lorta/">Lorta</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-supervisor" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/02/supervisor/" class="article-date">
  	<time datetime="2018-09-02T01:26:37.000Z" itemprop="datePublished">2018-09-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/02/supervisor/">
        supervisor
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python-进程管理工具-Supervisor-使用教程"><a href="#Python-进程管理工具-Supervisor-使用教程" class="headerlink" title="Python 进程管理工具 Supervisor 使用教程"></a>Python 进程管理工具 Supervisor 使用教程</h1><h3 id="Lorta：-supervisor"><a href="#Lorta：-supervisor" class="headerlink" title="Lorta： supervisor"></a>Lorta： supervisor</h3><p>转载：<a href="https://www.restran.net/2015/10/04/supervisord-tutorial/" target="_blank" rel="noopener">https://www.restran.net/2015/10/04/supervisord-tutorial/</a></p>
<hr>
<p><strong>Supervisor</strong> 是基于 Python 的进程管理工具，可以帮助我们更简单的启动、重启和停止服务器上的后台进程，是 Linux 服务器管理的效率工具。</p>
<p>什么情况下我们需要进程管理呢？就是执行一些需要以守护进程方式启动的程序，比如一个后台任务、一组 Web 服务的进程（说是一组，是因为经常用 Nginx 来做负载均衡），这些很可能是一些网站、REST API 的服务、消息推送的后台服务、日志数据的处理分析服务等等。</p>
<blockquote>
<p>需要注意的是 Supervisor 是通用的进程管理工具，可以用来启动任意进程，不仅仅是用来管理 Python 进程。</p>
</blockquote>
<p><strong>Supervisor</strong> 经常被用来管理由 gunicorn 启动的 Django 或 Flask 等 Web 服务的进程。我最常用的是用来管理和启动一组 Tornado 进程来实现负载均衡。</p>
<p>除此之外，Supervisor 还能很友好的管理程序在命令行上输出的日志，可以将日志重定向到自定义的日志文件中，还能按文件大小对日志进行分割。</p>
<p>目前 Supervisor 只能运行在 Unix-Like 的系统上，也就是无法运行在 Windows 上。Supervisor 官方版目前只能运行在 Python 2.4 以上版本，但是还无法运行在 Python 3 上，不过已经有一个 Python 3 的移植版 supervisor-py3k。</p>
<h2 id="Supervisor-有两个主要的组成部分："><a href="#Supervisor-有两个主要的组成部分：" class="headerlink" title="Supervisor 有两个主要的组成部分："></a>Supervisor 有两个主要的组成部分：</h2><ol>
<li><strong>supervisord</strong>，运行 Supervisor 时会启动一个进程 supervisord，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。</li>
<li><strong>supervisorctl</strong>，是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>sudo pip install supervisor</p>
</blockquote>
<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><blockquote>
<p>echo_supervisord_conf &gt; /etc/supervisord.conf</p>
</blockquote>
</li>
</ol>
<p>如果出现没有权限的问题，可以使用这条命令</p>
<blockquote>
<p>sudo su - root -c “echo_supervisord_conf &gt; /etc/supervisord.conf”</p>
</blockquote>
<h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><p>想要了解怎么配置需要管理的进程，只要打开 supervisord.conf 就可以了，里面有很详细的注释信息。</p>
<h2 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h2><blockquote>
<p>vim /etc/supervisord.conf</p>
</blockquote>
<p>默认的配置文件是下面这样的，但是这里有个坑需要注意，supervisord.pid 以及 supervisor.sock 是放在 /tmp 目录下，但是 /tmp 目录是存放临时文件，里面的文件是会被 Linux 系统删除的，一旦这些文件丢失，就无法再通过 supervisorctl 来执行 restart 和 stop 命令了，将只会得到 unix:///tmp/supervisor.sock 不存在的错误 。</p>
<p>因此可以单独建一个文件夹，来存放这些文件，比如放在 /home/supervisor/</p>
<h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>mkdir /home/supervisor<br>mkdir /var/log/supervisor<br>mkdir /etc/supervisor.d<br>然后对一些配置进行修改</p>
<blockquote>
<p>[unix_http_server]<br>;file=/tmp/supervisor.sock   ; (the path to the socket file)<br>;修改为 /home/supervisor 目录，避免被系统删除<br>file=/home/supervisor/supervisor.sock   ; (the path to the socket file)<br>;chmod=0700                 ; socket file mode (default 0700)<br>;chown=nobody:nogroup       ; socket file uid:gid owner<br>;username=user              ; (default is no username (open server))<br>;password=123               ; (default is no password (open server))<br>;[inet_http_server]         ; inet (TCP) server disabled by default<br>;port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for ;all iface)<br>;username=user              ; (default is no username (open server))<br>;password=123               ; (default is no password (open server))<br>…<br>[supervisord]<br>;logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log)<br>;修改为 /var/log 目录，避免被系统删除<br>logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)<br>; 日志文件多大时进行分割<br>logfile_maxbytes=50MB        ; (max main logfile bytes b4 rotation;default 50MB)<br>; 最多保留多少份日志文件<br>logfile_backups=10           ; (num of main logfile rotation backups;default 10)<br>loglevel=info                ; (log level;default info; others: debug,warn,trace)<br>;pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid)<br>;修改为 /home/supervisor 目录，避免被系统删除<br>pidfile=/home/supervisor/supervisord.pid ; (supervisord pidfile;default supervisord.pid)<br>…<br>;设置启动supervisord的用户，一般情况下不要轻易用root用户来启动，除非你真的确定要这么做<br>;user=chrism                 ; (default is current user, required if root)<br>…<br>[supervisorctl]<br>; 必须和’unix_http_server’里面的设定匹配<br>;serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  for a unix socket<br>;修改为 /home/supervisor 目录，避免被系统删除<br>serverurl=unix:///home/supervisor/supervisor.sock ; use a unix:// URL  for a unix socket<br>;serverurl=<a href="http://127.0.0.1:9001" target="_blank" rel="noopener">http://127.0.0.1:9001</a> ; use an http:// url to specify an inet socket<br>;username=chris              ; should be same as http_username if set<br>;password=123                ; should be same as http_password if set<br>…</p>
</blockquote>
<p>默认情况下，进程的日志文件达到50MB时，将进行分割，最多保留10个文件，当然这些配置也可以对每个进程单独配置。</p>
<h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>设置好配置文件后，应先创建上述配置文件中新增的文件夹。如果指定了启动用户 user，这里以 oxygen 为例，那么应注意相关文件的权限问题，包括日志文件，否则会出现没有权限的错误。例如设置了启动用户 oxygen，然后启动 supervisord 出现错误</p>
<blockquote>
<p>Error: Cannot open an HTTP server: socket.error reported errno.EACCES (13)</p>
</blockquote>
<p>就是由于上面的配置文件中 /home/supervisor 文件夹，没有授予启动 supervisord 的用户 oxygen 的写权限，可以将这个文件夹的拥有者设置该该账号</p>
<blockquote>
<p>sudo chown oxygen /home/supervisor</p>
</blockquote>
<p>一般情况下，我们可以用 root 用户启动 supervisord 进程，然后在其所管理的进程中，再具体指定需要以那个用户启动这些进程。</p>
<p>使用浏览器来管理<br>supervisor 同时提供了通过浏览器来管理进程的方法，只需要注释掉如下几行就可以了。</p>
<blockquote>
<p>;[inet_http_server]         ; inet (TCP) server disabled by default<br>;port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for ;all iface)<br>;username=user              ; (default is no username (open server))<br>;password=123               ; (default is no password (open server))</p>
</blockquote>
<p>[supervisorctl]<br>…<br>;serverurl=<a href="http://127.0.0.1:9001" target="_blank" rel="noopener">http://127.0.0.1:9001</a> ; use an http:// url to specify an inet socket<br>;username=chris              ; should be same as http_username if set<br>;password=123                ; should be same as http_password if set<br>http_supervisorctl</p>
<p>使用 include<br>在配置文件的最后，有一个 [include] 的配置项，跟 Nginx 一样，可以 include 某个文件夹下的所有配置文件，这样我们就可以为每个进程或相关的几个进程的配置单独写成一个文件。</p>
<blockquote>
<p>[include]<br>files = /etc/supervisor.d/*.ini</p>
</blockquote>
<h2 id="进程的配置样例"><a href="#进程的配置样例" class="headerlink" title="进程的配置样例"></a>进程的配置样例</h2><p>一个简单的例子如下</p>
<blockquote>
<p>; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名<br>[program:your_program_name]<br>command=python server.py –port=9000<br>;numprocs=1                 ; 默认为1<br>;process_name=%(program_name)s   ; 默认为 %(program_name)s，即 [program:x] 中的 x<br>directory=/home/python/tornado_server ; 执行 command 之前，先切换到工作目录<br>user=oxygen                 ; 使用 oxygen 用户来启动该进程<br>; 程序崩溃时自动重启，重启次数是有限制的，默认为3次<br>autorestart=true<br>redirect_stderr=true        ; 重定向输出的日志<br>stdout_logfile = /var/log/supervisor/tornado_server.log<br>loglevel=info</p>
</blockquote>
<h2 id="设置日志级别"><a href="#设置日志级别" class="headerlink" title="设置日志级别"></a>设置日志级别</h2><p>loglevel 指定了日志的级别，用 Python 的 print 语句输出的日志是不会被记录到日志文件中的，需要搭配 Python 的 logging 模块来输出有指定级别的日志。</p>
<h2 id="多个进程"><a href="#多个进程" class="headerlink" title="多个进程"></a>多个进程</h2><p>按照官方文档的定义，一个 [program:x] 实际上是表示一组相同特征或同类的进程组，也就是说一个 [program:x] 可以启动多个进程。这组进程的成员是通过 numprocs 和 process_name 这两个参数来确定的，这句话什么意思呢，我们来看这个例子。</p>
<blockquote>
<p>; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名<br>[program:foo]<br>; 可以在 command 这里用 python 表达式传递不同的参数给每个进程<br>command=python server.py –port=90%(process_num)02d<br>directory=/home/python/tornado_server ; 执行 command 之前，先切换到工作目录<br>; 若 numprocs 不为1，process_name 的表达式中一定要包含 process_num 来区分不同的进程<br>numprocs=2<br>process_name=%(program_name)s_%(process_num)02d;<br>user=oxygen                 ; 使用 oxygen 用户来启动该进程<br>autorestart=true            ; 程序崩溃时自动重启<br>redirect_stderr=true        ; 重定向输出的日志<br>stdout_logfile = /var/log/supervisor/tornado_server.log<br>loglevel=info</p>
</blockquote>
<p>上面这个例子会启动两个进程，process_name 分别为 foo:foo_01 和 foo:foo_02。通过这样一种方式，就可以用一个 [program:x] 配置项，来启动一组非常类似的进程。</p>
<p>再介绍两个配置项 stopasgroup 和 killasgroup</p>
<blockquote>
<p>; 默认为 false，如果设置为 true，当进程收到 stop 信号时，会自动将该信号发给该进程的子进程。如果这个配置项为 true，那么也隐含 killasgroup 为 true。例如在 Debug 模式使用 Flask 时，Flask 不会将接收到的 stop 信号也传递给它的子进程，因此就需要设置这个配置项。<br>stopasgroup=false             ; send stop signal to the UNIX process </p>
</blockquote>
<p>; 默认为 false，如果设置为 true，当进程收到 kill 信号时，会自动将该信号发给该进程的子进程。如果这个程序使用了 python 的 multiprocessing 时，就能自动停止它的子线程。<br>killasgroup=false             ; SIGKILL the UNIX process group (def false)</p>
<p>更详细的配置例子，可以参考如下，官方文档在这里</p>
<blockquote>
<p>;[program:theprogramname]<br>;command=/bin/cat              ; the program (relative uses PATH, can take args)<br>;process_name=%(program_name)s ; process_name expr (default %(program_name)s)<br>;numprocs=1                    ; number of processes copies to start (def 1)<br>;directory=/tmp                ; directory to cwd to before exec (def no cwd)<br>;umask=022                     ; umask for process (default None)<br>;priority=999                  ; the relative start priority (default 999)<br>;autostart=true                ; start at supervisord start (default: true)<br>;autorestart=unexpected        ; whether/when to restart (default: unexpected)<br>;startsecs=1                   ; number of secs prog must stay running (def. 1)<br>;startretries=3                ; max # of serial start failures (default 3)<br>;exitcodes=0,2                 ; ‘expected’ exit codes for process (default 0,2)<br>;stopsignal=QUIT               ; signal used to kill process (default TERM)<br>;stopwaitsecs=10               ; max num secs to wait b4 SIGKILL (default 10)<br>;stopasgroup=false             ; send stop signal to the UNIX process group (default false)<br>;killasgroup=false             ; SIGKILL the UNIX process group (def false)<br>;user=chrism                   ; setuid to this UNIX account to run the program<br>;redirect_stderr=true          ; redirect proc stderr to stdout (default false)<br>;stdout_logfile=/a/path        ; stdout log path, NONE for none; default AUTO<br>;stdout_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)<br>;stdout_logfile_backups=10     ; # of stdout logfile backups (default 10)<br>;stdout_capture_maxbytes=1MB   ; number of bytes in ‘capturemode’ (default 0)<br>;stdout_events_enabled=false   ; emit events on stdout writes (default false)<br>;stderr_logfile=/a/path        ; stderr log path, NONE for none; default AUTO<br>;stderr_logfile_maxbytes=1MB   ; max # logfile bytes b4 rotation (default 50MB)<br>;stderr_logfile_backups=10     ; # of stderr logfile backups (default 10)<br>;stderr_capture_maxbytes=1MB   ; number of bytes in ‘capturemode’ (default 0)<br>;stderr_events_enabled=false   ; emit events on stderr writes (default false)<br>;environment=A=”1”,B=”2”       ; process environment additions (def no adds)<br>;serverurl=AUTO                ; override serverurl computation (childutils)</p>
</blockquote>
<h2 id="将多个进程按组管理"><a href="#将多个进程按组管理" class="headerlink" title="将多个进程按组管理"></a>将多个进程按组管理</h2><p>Supervisor 同时还提供了另外一种进程组的管理方式，通过这种方式，可以使用 supervisorctl 命令来管理一组进程。跟 [program:x] 的进程组不同的是，这里的进程是一个个的 [program:x] 。</p>
<blockquote>
<p>[group:thegroupname]<br>programs=progname1,progname2  ; each refers to ‘x’ in [program:x] definitions<br>priority=999                  ; the relative start priority (default 999)</p>
</blockquote>
<p>当添加了上述配置后，progname1 和 progname2 的进程名就会变成 thegroupname:progname1 和 thegroupname:progname2 以后就要用这个名字来管理进程了，而不是之前的 progname1。</p>
<p>以后执行 supervisorctl stop thegroupname: 就能同时结束 progname1 和 progname2，执行 supervisorctl stop thegroupname:progname1 就能结束 progname1。supervisorctl 的命令我们稍后介绍。</p>
<h2 id="启动-supervisord"><a href="#启动-supervisord" class="headerlink" title="启动 supervisord"></a>启动 supervisord</h2><p>执行 supervisord 命令，将会启动 supervisord 进程，同时我们在配置文件中设置的进程也会相应启动。</p>
<blockquote>
<p>使用默认的配置文件 /etc/supervisord.conf<br>supervisord<br>明确指定配置文件<br>supervisord -c /etc/supervisord.conf<br>使用 user 用户启动 supervisord<br>supervisord -u user<br>更多参数请参考文档</p>
</blockquote>
<h2 id="supervisorctl-命令介绍"><a href="#supervisorctl-命令介绍" class="headerlink" title="supervisorctl 命令介绍"></a>supervisorctl 命令介绍</h2><blockquote>
<p># 停止某一个进程，program_name 为 [program:x] 里的 x<br>supervisorctl stop program_name<br># 启动某个进程<br>supervisorctl start program_name<br># 重启某个进程<br>supervisorctl restart program_name<br># 结束所有属于名为 groupworker 这个分组的进程 (start，restart 同理)<br>supervisorctl stop groupworker:<br># 结束 groupworker:name1 这个进程 (start，restart 同理)<br>supervisorctl stop groupworker:name1<br># 停止全部进程，注：start、restart、stop 都不会载入最新的配置文件<br>supervisorctl stop all<br># 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程<br>supervisorctl reload<br># 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启<br>supervisorctl update</p>
</blockquote>
<p><strong>注意：</strong>显示用 stop 停止掉的进程，用 reload 或者 update 都不会自动重启。也可以参考这里</p>
<h2 id="开机自动启动-Supervisord"><a href="#开机自动启动-Supervisord" class="headerlink" title="开机自动启动 Supervisord"></a>开机自动启动 Supervisord</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>有一个简单的方法，因为 Linux 在启动的时候会执行 /etc/rc.local 里面的脚本，所以只要在这里添加执行命令就可以</p>
<p># 如果是 Ubuntu 添加以下内容</p>
<blockquote>
<p>/usr/local/bin/supervisord -c /etc/supervisord.conf</p>
</blockquote>
<p># 如果是 Centos 添加以下内容</p>
<blockquote>
<p>/usr/bin/supervisord -c /etc/supervisord.conf</p>
</blockquote>
<p>以上内容需要添加在 exit 命令前，而且由于在执行 rc.local 脚本时，PATH 环境变量未全部初始化，因此命令需要使用绝对路径。可以用 which supervisord 查看一下 supervisord 所在的路径。</p>
<p>在添加前，先在终端测试一下命令是否能正常执行，如果找不到 supervisord，可以用如下命令找到</p>
<blockquote>
<p>sudo find / -name supervisord</p>
</blockquote>
<blockquote>
<p>如果是 Ubuntu 16.04 以上，rc.local 被当成了服务，而且默认是不会启动，需要手动启用一下服务。<br><a href="https://askubuntu.com/questions/765120/after-upgrade-to-16-04-lts-rc-local-not-executing-command" target="_blank" rel="noopener">https://askubuntu.com/questions/765120/after-upgrade-to-16-04-lts-rc-local-not-executing-command</a></p>
</blockquote>
<p>启用 rc.local 服务</p>
<blockquote>
<p>sudo systemctl enable rc-local.service</p>
</blockquote>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>Supervisord 默认情况下并没有被安装成服务，它本身也是一个进程。官方已经给出了脚本可以将 Supervisord 安装成服务，可以参考这里查看各种操作系统的安装脚本，但是我用官方这里给的 Ubuntu 脚本却无法运行。</p>
<p>安装方法可以参考 serverfault 上的回答。</p>
<p>比如我是 Ubuntu 系统，可以这么安装，这里选择了另外一个脚本</p>
<blockquote>
<p># 下载脚本<br>sudo su - root -c “sudo curl <a href="https://gist.githubusercontent.com/howthebodyworks/176149/raw/d60b505a585dda836fadecca8f6b03884153196b/supervisord.sh" target="_blank" rel="noopener">https://gist.githubusercontent.com/howthebodyworks/176149/raw/d60b505a585dda836fadecca8f6b03884153196b/supervisord.sh</a> &gt; /etc/init.d/supervisord”<br># 设置该脚本为可以执行<br>sudo chmod +x /etc/init.d/supervisord<br># 设置为开机自动运行<br>sudo update-rc.d supervisord defaults<br># 试一下，是否工作正常<br>service supervisord stop<br>service supervisord start</p>
</blockquote>
<p><strong>注意：</strong>这个脚本下载下来后，还需检查一下与我们的配置是否相符合，比如默认的配置文件路径，pid 文件路径等，如果存在不同则需要进行一些修改。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Lorta/">Lorta</a><a class="article-category-link" href="/categories/Lorta/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-datalib" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/12/datalib/" class="article-date">
  	<time datetime="2018-08-12T03:38:03.000Z" itemprop="datePublished">2018-08-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/12/datalib/">
        datalib
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2019 Taylor
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a> 
        </div>
    </div>
  </div>
</footer>

    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		particlesjs:false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>



  </div>
</body>
</html>